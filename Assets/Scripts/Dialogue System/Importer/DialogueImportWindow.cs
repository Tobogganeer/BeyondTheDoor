using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using ToBOE.Dialogue.Importer.CodeGen;
using System.Security.Cryptography;
using static UnityEditor.LightingExplorerTableColumn;

namespace ToBOE.Dialogue.Importer
{
    public class DialogueImportWindow : EditorWindow
    {
        TextAsset tsvFile;
        LineParser.RawLineCollection rawLines;

        [MenuItem("Dialogue/Import Window")]
        public static void ShowWindow()
        {
            DialogueImportWindow window = EditorWindow.GetWindow<DialogueImportWindow>();
            window.titleContent = new GUIContent("Import Dialogue");
            window.minSize = new Vector2(300, 400);
        }

        private void OnGUI()
        {
            tsvFile = EditorGUILayout.ObjectField("Lines File", tsvFile, typeof(TextAsset), false) as TextAsset;
            if (tsvFile == null)
                GUI.enabled = false;

            if (GUILayout.Button("Process TSV"))
            {
                rawLines = LineParser.ParseRawLines(tsvFile.text);
            }

            GUI.enabled = true;

            if (rawLines != null)
            {
                EditorGUILayout.LabelField("Raw lines loaded: " + rawLines.RawLines.Count);

                if (rawLines.IsValid)
                    LinesValid();
                else
                    LinesInvalid();
            }
        }

        void LinesValid()
        {

        }

        void LinesInvalid()
        {
            EditorGUILayout.LabelField("Lines invalid: " + rawLines.InvalidLines.Count +
                ". Reason(s): " + rawLines.InvalidElements);

            bool charactersInvalid = rawLines.InvalidElements.HasFlag(LineParser.LineDataType.Character);
            bool lineIDsInvalid = rawLines.InvalidElements.HasFlag(LineParser.LineDataType.LineID);
            bool lineStatusesInvalid = rawLines.InvalidElements.HasFlag(LineParser.LineDataType.LineStatus);
            bool voiceStatusesInvalid = rawLines.InvalidElements.HasFlag(LineParser.LineDataType.VoiceStatus);

            if (charactersInvalid || lineIDsInvalid || lineStatusesInvalid || voiceStatusesInvalid)
            {
                EditorGUILayout.LabelField("Enums may be invalid.");
                if (GUILayout.Button("Generate Enums"))
                {
                    GenerateEnums(charactersInvalid, lineIDsInvalid, lineStatusesInvalid, voiceStatusesInvalid);
                }
            }
        }

        void GenerateEnums(bool chars, bool ids, bool stats, bool voices)
        {
            if (chars)
                GenerateEnum(nameof(Character), LineParser.LineDataType.Character);
            if (ids)
                GenerateEnum(nameof(LineID), LineParser.LineDataType.LineID);
            if (stats)
                GenerateEnum(nameof(LineStatus), LineParser.LineDataType.LineStatus);
            if (voices)
                GenerateEnum(nameof(VoiceStatus), LineParser.LineDataType.VoiceStatus);
        }

        void GenerateEnum(string enumName, LineParser.LineDataType dataType)
        {
            EnumGenerator gen = new EnumGenerator(enumName, FilePaths.Autogenerated, FilePaths.DialogueNamespace);
            foreach (string data in rawLines.GetAllData(dataType))
                gen.Add(data, data.GetHashCode());
            gen.Generate();
        }
    }
}
