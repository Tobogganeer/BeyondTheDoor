using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

namespace ToBOE.Dialogue.Importer.CodeGen
{
    public static class LineGenerator
    {
        /*
        /// <summary>
        /// Generates a Line from RawLineData, but likely not even necessary.
        /// </summary>
        /// <param name="rawLine"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static Line Generate(LineParser.RawLineData rawLine)
        {
            // Make sure it is all good
            if (rawLine == null)
                throw new ArgumentNullException(nameof(rawLine));
            if (!rawLine.IsValid)
                throw new ArgumentException("Passed line was not valid.", nameof(rawLine));

            Line l = new Line();

            // Booooring
            l.character = Enum.Parse<Character>(rawLine.character);
            l.text = rawLine.text;
            l.context = rawLine.context;
            l.day = int.Parse(rawLine.day);
            l.id = Enum.Parse<LineID>(rawLine.id);
            l.lineStatus = Enum.Parse<LineStatus>(rawLine.lineStatus);
            l.voiceStatus = Enum.Parse<VoiceStatus>(rawLine.voiceStatus);

            return l;
        }
        */

        /// <summary>
        /// Saves all of the <paramref name="rawLines"/> to disk. All lines must be valid.
        /// </summary>
        /// <param name="rawLines"></param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void GenerateLinesFile(LineParser.RawLineCollection rawLines)
        {
            if (rawLines == null)
                throw new ArgumentNullException(nameof(rawLines));
            if (!rawLines.IsValid)
                throw new ArgumentException("Passed lines were not valid.", nameof(rawLines));
            if (rawLines.RawLines == null)
                throw new ArgumentNullException(nameof(rawLines.RawLines));

            CodeFile cf = new CodeFile(nameof(Line) + ".Autogenerated", FilePaths.Autogenerated);

            cf.AddAutoGeneratedPreamble();

            // Dictionary for Lines dict
            cf.AddUsingDirective("System.Collections.Generic");
            cf.Space();

            using (cf.Namespace(FilePaths.DialogueNamespace))
            {
                using (cf.Class(CodeFile.Modifiers.Public | CodeFile.Modifiers.Partial, nameof(Line)))
                {
                    foreach (var line in rawLines.RawLines)
                    {
                        GenerateLineCode(line, cf);
                    }

                    GenerateAllLinesDict(rawLines, cf);
                }
            }

            cf.SaveToDisk();
        }

        static void GenerateLineCode(LineParser.RawLineData line, CodeFile cf)
        {
            System.Text.StringBuilder sb = cf.GetStringBuilder();

            // Character character, string text, string context, int day, LineID id,
            // LineStatus lineStatus, VoiceStatus voiceStatus, string extraData
            cf.ApplyIndent();
            sb.Append("public static Line ").Append(line.id).Append(" { get; private set; } = new Line(");
            sb.Append(nameof(CharacterID)).Append(".").Append(line.character).Append(", ");
            sb.Append('"').Append(SanitizeForCodeGen(line.text)).Append("\", ");
            sb.Append('"').Append(SanitizeForCodeGen(line.context)).Append("\", ");
            sb.Append(line.day).Append(", ");
            sb.Append(nameof(LineID)).Append(".").Append(line.id).Append(", ");
            sb.Append(nameof(LineStatus)).Append(".").Append(line.lineStatus).Append(", ");
            sb.Append(nameof(VoiceStatus)).Append(".").Append(line.voiceStatus).Append(", ");
            sb.Append('"').Append(SanitizeForCodeGen(line.extraData)).Append("\");");
            sb.AppendLine();
        }

        static string SanitizeForCodeGen(string textInput)
        {
            if (string.IsNullOrEmpty(textInput))
                return null;

            // Get rid of wrapping quotes, but not ones in middle
            if (textInput.StartsWith('"') && textInput.EndsWith('"'))
                textInput = textInput.Substring(1, textInput.Length - 2);

            return textInput.Replace("\"", "\\\"");
        }

        static void GenerateAllLinesDict(LineParser.RawLineCollection rawLines, CodeFile cf)
        {
            GenerateLineDict(cf, "All", rawLines.RawLines, "All lines that can be used.");
        }

        static void GenerateLineDict(CodeFile cf, string dictName, List<LineParser.RawLineData> lines, string xmlComment = null)
        {
            System.Text.StringBuilder sb = cf.GetStringBuilder();

            cf.Space();
            if (xmlComment != null)
            {
                cf.ApplyIndent().AppendLine("/// <summary>");
                cf.ApplyIndent().Append("/// ").AppendLine(xmlComment);
                cf.ApplyIndent().AppendLine("/// <summary>");
            }
            cf.ApplyIndent();
            sb.Append("public static Dictionary<LineID, Line> ").Append(dictName).Append(" { get; private set; } = new Dictionary<LineID, Line>()");
            using (new CodeFile.Scope(cf, true))
            {
                foreach (var rawLine in lines)
                {
                    cf.ApplyIndent();
                    sb.Append("{ LineID.").Append(rawLine.id).Append(", ").Append(rawLine.id).AppendLine(" },");
                }
            }
        }



        /// <summary>
        /// Removes all lines from the Line.Autogenerated file. Useful if enums are being regenerated.
        /// </summary>
        public static void ClearLinesFile()
        {
            CodeFile cf = new CodeFile(nameof(Line) + ".Autogenerated", FilePaths.Autogenerated);
            cf.AddAutoGeneratedPreamble();

            cf.AddComment("This file was intentionally cleared by the code generator.");

            cf.SaveToDisk();
        }
    }
}
